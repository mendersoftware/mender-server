/*
Mender API

Combined API specification for the features of the different Mender backend services, suitable for code generation applications

API version: 1
Contact: support@mender.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// DeploymentsDeviceAPIAPIService DeploymentsDeviceAPIAPI service
type DeploymentsDeviceAPIAPIService service

type ApiCheckUpdateRequest struct {
	ctx          context.Context
	ApiService   *DeploymentsDeviceAPIAPIService
	artifactName *string
	deviceType   *string
}

// currently installed artifact
func (r ApiCheckUpdateRequest) ArtifactName(artifactName string) ApiCheckUpdateRequest {
	r.artifactName = &artifactName
	return r
}

// Device type of device
func (r ApiCheckUpdateRequest) DeviceType(deviceType string) ApiCheckUpdateRequest {
	r.deviceType = &deviceType
	return r
}

func (r ApiCheckUpdateRequest) Execute() (*DeploymentInstructions, *http.Response, error) {
	return r.ApiService.CheckUpdateExecute(r)
}

/*
CheckUpdate Get next update

On success, either an empty response or a DeploymentInstructions object
is returned depending on whether there are any pending updates.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCheckUpdateRequest
*/
func (a *DeploymentsDeviceAPIAPIService) CheckUpdate(ctx context.Context) ApiCheckUpdateRequest {
	return ApiCheckUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeploymentInstructions
func (a *DeploymentsDeviceAPIAPIService) CheckUpdateExecute(r ApiCheckUpdateRequest) (*DeploymentInstructions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeploymentInstructions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsDeviceAPIAPIService.CheckUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/v1/deployments/device/deployments/next"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.artifactName == nil {
		return localVarReturnValue, nil, reportError("artifactName is required and must be specified")
	}
	if r.deviceType == nil {
		return localVarReturnValue, nil, reportError("deviceType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "artifact_name", r.artifactName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", r.deviceType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchConfigurationRequest struct {
	ctx           context.Context
	ApiService    *DeploymentsDeviceAPIAPIService
	deploymentId  string
	deviceType    string
	deviceId      string
	xMenExpire    *time.Time
	xMenSignature *string
	tenantId      *string
}

// Time of link expire
func (r ApiFetchConfigurationRequest) XMenExpire(xMenExpire time.Time) ApiFetchConfigurationRequest {
	r.xMenExpire = &xMenExpire
	return r
}

// Signature of the URL link
func (r ApiFetchConfigurationRequest) XMenSignature(xMenSignature string) ApiFetchConfigurationRequest {
	r.xMenSignature = &xMenSignature
	return r
}

// Device tenant ID
func (r ApiFetchConfigurationRequest) TenantId(tenantId string) ApiFetchConfigurationRequest {
	r.tenantId = &tenantId
	return r
}

func (r ApiFetchConfigurationRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.FetchConfigurationExecute(r)
}

/*
FetchConfiguration Internally generated download link for deploying device configurations. All parameters are generated internally when fetching a configuration deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param deploymentId Deployment UUID
	@param deviceType Device type of the calling device
	@param deviceId Device UUID
	@return ApiFetchConfigurationRequest
*/
func (a *DeploymentsDeviceAPIAPIService) FetchConfiguration(ctx context.Context, deploymentId string, deviceType string, deviceId string) ApiFetchConfigurationRequest {
	return ApiFetchConfigurationRequest{
		ApiService:   a,
		ctx:          ctx,
		deploymentId: deploymentId,
		deviceType:   deviceType,
		deviceId:     deviceId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DeploymentsDeviceAPIAPIService) FetchConfigurationExecute(r ApiFetchConfigurationRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsDeviceAPIAPIService.FetchConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/v1/deployments/download/configuration/{deployment_id}/{device_type}/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_type"+"}", url.PathEscape(parameterValueToString(r.deviceType, "deviceType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xMenExpire == nil {
		return localVarReturnValue, nil, reportError("xMenExpire is required and must be specified")
	}
	if r.xMenSignature == nil {
		return localVarReturnValue, nil, reportError("xMenSignature is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "x-men-expire", r.xMenExpire, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "x-men-signature", r.xMenSignature, "form", "")
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", r.tenantId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportDeploymentLogRequest struct {
	ctx           context.Context
	ApiService    *DeploymentsDeviceAPIAPIService
	id            string
	deploymentLog *DeploymentLog
}

// Deployment log
func (r ApiReportDeploymentLogRequest) DeploymentLog(deploymentLog DeploymentLog) ApiReportDeploymentLogRequest {
	r.deploymentLog = &deploymentLog
	return r
}

func (r ApiReportDeploymentLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReportDeploymentLogExecute(r)
}

/*
ReportDeploymentLog Upload the device deployment log

Set the log of a selected deployment. Messages are split by line in the payload.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Deployment identifier.
	@return ApiReportDeploymentLogRequest
*/
func (a *DeploymentsDeviceAPIAPIService) ReportDeploymentLog(ctx context.Context, id string) ApiReportDeploymentLogRequest {
	return ApiReportDeploymentLogRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsDeviceAPIAPIService) ReportDeploymentLogExecute(r ApiReportDeploymentLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsDeviceAPIAPIService.ReportDeploymentLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/v1/deployments/device/deployments/{id}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentLog == nil {
		return nil, reportError("deploymentLog is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentLog
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDeploymentStatusRequest struct {
	ctx              context.Context
	ApiService       *DeploymentsDeviceAPIAPIService
	id               string
	deploymentStatus *DeploymentStatus
}

// Deployment status.
func (r ApiUpdateDeploymentStatusRequest) DeploymentStatus(deploymentStatus DeploymentStatus) ApiUpdateDeploymentStatusRequest {
	r.deploymentStatus = &deploymentStatus
	return r
}

func (r ApiUpdateDeploymentStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeploymentStatusExecute(r)
}

/*
UpdateDeploymentStatus Update the device deployment status

Updates the status of a deployment on a particular device. Final status
of the deployment is required to be set to indicate the success or failure
of the installation process. The status can not be changed when deployment
status is set to aborted. Reporting of intermediate steps such as
installing, downloading, rebooting is optional.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Deployment identifier.
	@return ApiUpdateDeploymentStatusRequest
*/
func (a *DeploymentsDeviceAPIAPIService) UpdateDeploymentStatus(ctx context.Context, id string) ApiUpdateDeploymentStatusRequest {
	return ApiUpdateDeploymentStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsDeviceAPIAPIService) UpdateDeploymentStatusExecute(r ApiUpdateDeploymentStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsDeviceAPIAPIService.UpdateDeploymentStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/v1/deployments/device/deployments/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deploymentStatus == nil {
		return nil, reportError("deploymentStatus is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentStatus
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
