/*
Mender API

Combined API specification for the features of the different Mender backend services, suitable for code generation applications

API version: 1
Contact: support@mender.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
)

// DeploymentsInternalAPIInternalAPIAPIService DeploymentsInternalAPIInternalAPIAPI service
type DeploymentsInternalAPIInternalAPIAPIService service

type ApiDeploymentsInternalCheckHealthRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
}

func (r ApiDeploymentsInternalCheckHealthRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeploymentsInternalCheckHealthExecute(r)
}

/*
DeploymentsInternalCheckHealth Check the health of the service

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeploymentsInternalCheckHealthRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCheckHealth(ctx context.Context) ApiDeploymentsInternalCheckHealthRequest {
	return ApiDeploymentsInternalCheckHealthRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCheckHealthExecute(r ApiDeploymentsInternalCheckHealthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalCheckHealth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeploymentsInternalCheckLivelinessRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
}

func (r ApiDeploymentsInternalCheckLivelinessRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeploymentsInternalCheckLivelinessExecute(r)
}

/*
DeploymentsInternalCheckLiveliness Trivial endpoint that unconditionally returns an empty 204 response whenever the API handler is running correctly.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeploymentsInternalCheckLivelinessRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCheckLiveliness(ctx context.Context) ApiDeploymentsInternalCheckLivelinessRequest {
	return ApiDeploymentsInternalCheckLivelinessRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCheckLivelinessExecute(r ApiDeploymentsInternalCheckLivelinessRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalCheckLiveliness")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/alive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeploymentsInternalCreateDeploymentRequest struct {
	ctx                            context.Context
	ApiService                     *DeploymentsInternalAPIInternalAPIAPIService
	tenantId                       string
	deviceId                       string
	deploymentId                   string
	configurationDeploymentRequest *ConfigurationDeploymentRequest
}

// New deployment that needs to be created.
func (r ApiDeploymentsInternalCreateDeploymentRequest) ConfigurationDeploymentRequest(configurationDeploymentRequest ConfigurationDeploymentRequest) ApiDeploymentsInternalCreateDeploymentRequest {
	r.configurationDeploymentRequest = &configurationDeploymentRequest
	return r
}

func (r ApiDeploymentsInternalCreateDeploymentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeploymentsInternalCreateDeploymentExecute(r)
}

/*
DeploymentsInternalCreateDeployment Create a configuration deployment

Deploy configuration to a specified device.
The artifact will be auto-generated based on the configuration object
provided with the deployment constructor.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenantId Tenant identifier.
	@param deviceId Device identifier.
	@param deploymentId Deployment identifier.
	@return ApiDeploymentsInternalCreateDeploymentRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCreateDeployment(ctx context.Context, tenantId string, deviceId string, deploymentId string) ApiDeploymentsInternalCreateDeploymentRequest {
	return ApiDeploymentsInternalCreateDeploymentRequest{
		ApiService:   a,
		ctx:          ctx,
		tenantId:     tenantId,
		deviceId:     deviceId,
		deploymentId: deploymentId,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCreateDeploymentExecute(r ApiDeploymentsInternalCreateDeploymentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalCreateDeployment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{tenant_id}/configuration/deployments/{deployment_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant_id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deployment_id"+"}", url.PathEscape(parameterValueToString(r.deploymentId, "deploymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configurationDeploymentRequest == nil {
		return nil, reportError("configurationDeploymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configurationDeploymentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeploymentsInternalCreateTenantRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	newTenant  *NewTenant
}

// New tenant descriptor.
func (r ApiDeploymentsInternalCreateTenantRequest) NewTenant(newTenant NewTenant) ApiDeploymentsInternalCreateTenantRequest {
	r.newTenant = &newTenant
	return r
}

func (r ApiDeploymentsInternalCreateTenantRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeploymentsInternalCreateTenantExecute(r)
}

/*
DeploymentsInternalCreateTenant Provision a new tenant

Sets up all tenant-related infrastructure, e.g. a migrated tenant's database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeploymentsInternalCreateTenantRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCreateTenant(ctx context.Context) ApiDeploymentsInternalCreateTenantRequest {
	return ApiDeploymentsInternalCreateTenantRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalCreateTenantExecute(r ApiDeploymentsInternalCreateTenantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalCreateTenant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newTenant == nil {
		return nil, reportError("newTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newTenant
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeploymentsInternalGetStorageUsageRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	id         string
}

func (r ApiDeploymentsInternalGetStorageUsageRequest) Execute() (*StorageUsage, *http.Response, error) {
	return r.ApiService.DeploymentsInternalGetStorageUsageExecute(r)
}

/*
DeploymentsInternalGetStorageUsage Get storage limit and current storage usage for given tenant

Get storage limit and current storage usage for given tenant.
If the limit value is 0 it means storage space is unlimited

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID
	@return ApiDeploymentsInternalGetStorageUsageRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalGetStorageUsage(ctx context.Context, id string) ApiDeploymentsInternalGetStorageUsageRequest {
	return ApiDeploymentsInternalGetStorageUsageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return StorageUsage
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalGetStorageUsageExecute(r ApiDeploymentsInternalGetStorageUsageRequest) (*StorageUsage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StorageUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalGetStorageUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/limits/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeploymentsInternalListDeploymentsForADeviceRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	tenantId   string
	id         string
	status     *string
	page       *int32
	perPage    *int32
}

// Filter deployments by status for the given device.
func (r ApiDeploymentsInternalListDeploymentsForADeviceRequest) Status(status string) ApiDeploymentsInternalListDeploymentsForADeviceRequest {
	r.status = &status
	return r
}

// Starting page.
func (r ApiDeploymentsInternalListDeploymentsForADeviceRequest) Page(page int32) ApiDeploymentsInternalListDeploymentsForADeviceRequest {
	r.page = &page
	return r
}

// Maximum number of results per page.
func (r ApiDeploymentsInternalListDeploymentsForADeviceRequest) PerPage(perPage int32) ApiDeploymentsInternalListDeploymentsForADeviceRequest {
	r.perPage = &perPage
	return r
}

func (r ApiDeploymentsInternalListDeploymentsForADeviceRequest) Execute() ([]DeviceDeployment, *http.Response, error) {
	return r.ApiService.DeploymentsInternalListDeploymentsForADeviceExecute(r)
}

/*
DeploymentsInternalListDeploymentsForADevice Return the Deployments history for a Device

Return the Deployments history for the specified Device, listing all its Deployments.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenantId Tenant ID
	@param id System wide device identifier
	@return ApiDeploymentsInternalListDeploymentsForADeviceRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalListDeploymentsForADevice(ctx context.Context, tenantId string, id string) ApiDeploymentsInternalListDeploymentsForADeviceRequest {
	return ApiDeploymentsInternalListDeploymentsForADeviceRequest{
		ApiService: a,
		ctx:        ctx,
		tenantId:   tenantId,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []DeviceDeployment
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalListDeploymentsForADeviceExecute(r ApiDeploymentsInternalListDeploymentsForADeviceRequest) ([]DeviceDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeviceDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalListDeploymentsForADevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant_id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", defaultValue, "form", "")
		r.perPage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeploymentsInternalUploadArtifactRequest struct {
	ctx         context.Context
	ApiService  *DeploymentsInternalAPIInternalAPIAPIService
	id          string
	artifact    *os.File
	artifactId  *string
	size        *int32
	description *string
}

// Artifact. It has to be the last part of request.
func (r ApiDeploymentsInternalUploadArtifactRequest) Artifact(artifact *os.File) ApiDeploymentsInternalUploadArtifactRequest {
	r.artifact = artifact
	return r
}

// Artifact ID, optional; the server generates a randome one if not provided.
func (r ApiDeploymentsInternalUploadArtifactRequest) ArtifactId(artifactId string) ApiDeploymentsInternalUploadArtifactRequest {
	r.artifactId = &artifactId
	return r
}

// Size of the artifact file in bytes.
func (r ApiDeploymentsInternalUploadArtifactRequest) Size(size int32) ApiDeploymentsInternalUploadArtifactRequest {
	r.size = &size
	return r
}

func (r ApiDeploymentsInternalUploadArtifactRequest) Description(description string) ApiDeploymentsInternalUploadArtifactRequest {
	r.description = &description
	return r
}

func (r ApiDeploymentsInternalUploadArtifactRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeploymentsInternalUploadArtifactExecute(r)
}

/*
DeploymentsInternalUploadArtifact Upload mender artifact

Upload mender artifact to a specific tenant. Multipart request with meta and artifact.
Supports artifact [versions v1, v2, v3](https://docs.mender.io/overview/artifact#versions).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID, or \"default\" if running in non-multitenant setup
	@return ApiDeploymentsInternalUploadArtifactRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalUploadArtifact(ctx context.Context, id string) ApiDeploymentsInternalUploadArtifactRequest {
	return ApiDeploymentsInternalUploadArtifactRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) DeploymentsInternalUploadArtifactExecute(r ApiDeploymentsInternalUploadArtifactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.DeploymentsInternalUploadArtifact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.artifact == nil {
		return nil, reportError("artifact is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.artifactId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artifact_id", r.artifactId, "", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "size", r.size, "", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	var artifactLocalVarFormFileName string
	var artifactLocalVarFileName string
	var artifactLocalVarFileBytes []byte

	artifactLocalVarFormFileName = "artifact"
	artifactLocalVarFile := r.artifact

	if artifactLocalVarFile != nil {
		fbs, _ := io.ReadAll(artifactLocalVarFile)

		artifactLocalVarFileBytes = fbs
		artifactLocalVarFileName = artifactLocalVarFile.Name()
		artifactLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: artifactLocalVarFileBytes, fileName: artifactLocalVarFileName, formFileName: artifactLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDeploymentsRequest struct {
	ctx           context.Context
	ApiService    *DeploymentsInternalAPIInternalAPIAPIService
	id            string
	status        *string
	search        *string
	page          *int32
	createdBefore *int32
	createdAfter  *int32
	sort          *string
}

// Deployment status filter.
func (r ApiGetDeploymentsRequest) Status(status string) ApiGetDeploymentsRequest {
	r.status = &status
	return r
}

// Deployment name or description filter.
func (r ApiGetDeploymentsRequest) Search(search string) ApiGetDeploymentsRequest {
	r.search = &search
	return r
}

// Results page number
func (r ApiGetDeploymentsRequest) Page(page int32) ApiGetDeploymentsRequest {
	r.page = &page
	return r
}

// List only deployments created before and equal to Unix timestamp (UTC)
func (r ApiGetDeploymentsRequest) CreatedBefore(createdBefore int32) ApiGetDeploymentsRequest {
	r.createdBefore = &createdBefore
	return r
}

// List only deployments created after and equal to Unix timestamp (UTC)
func (r ApiGetDeploymentsRequest) CreatedAfter(createdAfter int32) ApiGetDeploymentsRequest {
	r.createdAfter = &createdAfter
	return r
}

// Supports sorting the deployments list by creation date.
func (r ApiGetDeploymentsRequest) Sort(sort string) ApiGetDeploymentsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetDeploymentsRequest) Execute() ([]DeploymentV1Internal, *http.Response, error) {
	return r.ApiService.GetDeploymentsExecute(r)
}

/*
GetDeployments Get all deployments for specific tenant

Returns a filtered collection of deployments in the system,
including active and historical. If both 'status' and 'query' are
not specified, all devices are listed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID
	@return ApiGetDeploymentsRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetDeployments(ctx context.Context, id string) ApiGetDeploymentsRequest {
	return ApiGetDeploymentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []DeploymentV1Internal
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetDeploymentsExecute(r ApiGetDeploymentsRequest) ([]DeploymentV1Internal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeploymentV1Internal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.GetDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_before", r.createdBefore, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_after", r.createdAfter, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastDeviceDeploymentStatusRequest struct {
	ctx                     context.Context
	ApiService              *DeploymentsInternalAPIInternalAPIAPIService
	tenantId                string
	lastDeviceDeploymentReq *LastDeviceDeploymentReq
}

func (r ApiGetLastDeviceDeploymentStatusRequest) LastDeviceDeploymentReq(lastDeviceDeploymentReq LastDeviceDeploymentReq) ApiGetLastDeviceDeploymentStatusRequest {
	r.lastDeviceDeploymentReq = &lastDeviceDeploymentReq
	return r
}

func (r ApiGetLastDeviceDeploymentStatusRequest) Execute() (*LastDeviceDeploymentsStatuses, *http.Response, error) {
	return r.ApiService.GetLastDeviceDeploymentStatusExecute(r)
}

/*
GetLastDeviceDeploymentStatus Get status of the last device devployment

Return the status of the last unsucessful device deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenantId Tenant identifier.
	@return ApiGetLastDeviceDeploymentStatusRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetLastDeviceDeploymentStatus(ctx context.Context, tenantId string) ApiGetLastDeviceDeploymentStatusRequest {
	return ApiGetLastDeviceDeploymentStatusRequest{
		ApiService: a,
		ctx:        ctx,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return LastDeviceDeploymentsStatuses
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetLastDeviceDeploymentStatusExecute(r ApiGetLastDeviceDeploymentStatusRequest) (*LastDeviceDeploymentsStatuses, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LastDeviceDeploymentsStatuses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.GetLastDeviceDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{tenant_id}/devices/deployments/last"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant_id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.lastDeviceDeploymentReq == nil {
		return localVarReturnValue, nil, reportError("lastDeviceDeploymentReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.lastDeviceDeploymentReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStorageSettingsRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	id         string
}

func (r ApiGetStorageSettingsRequest) Execute() (*StorageSettings, *http.Response, error) {
	return r.ApiService.GetStorageSettingsExecute(r)
}

/*
GetStorageSettings Get storage setting for a given tenant

Returns an object with per tenant storage layer specific settings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID
	@return ApiGetStorageSettingsRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetStorageSettings(ctx context.Context, id string) ApiGetStorageSettingsRequest {
	return ApiGetStorageSettingsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return StorageSettings
func (a *DeploymentsInternalAPIInternalAPIAPIService) GetStorageSettingsExecute(r ApiGetStorageSettingsRequest) (*StorageSettings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StorageSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.GetStorageSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/storage/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDeviceDeploymentsEntriesRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	tenantId   string
	id         *[]string
}

// Deployment Device ID filter. Can be repeated to query a set of entries.
func (r ApiListDeviceDeploymentsEntriesRequest) Id(id []string) ApiListDeviceDeploymentsEntriesRequest {
	r.id = &id
	return r
}

func (r ApiListDeviceDeploymentsEntriesRequest) Execute() ([]DeviceDeployment, *http.Response, error) {
	return r.ApiService.ListDeviceDeploymentsEntriesExecute(r)
}

/*
ListDeviceDeploymentsEntries Return the Deployments history entries for the specified IDs

# Return the Deployments history entries for the specified IDs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenantId Tenant ID
	@return ApiListDeviceDeploymentsEntriesRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) ListDeviceDeploymentsEntries(ctx context.Context, tenantId string) ApiListDeviceDeploymentsEntriesRequest {
	return ApiListDeviceDeploymentsEntriesRequest{
		ApiService: a,
		ctx:        ctx,
		tenantId:   tenantId,
	}
}

// Execute executes the request
//
//	@return []DeviceDeployment
func (a *DeploymentsInternalAPIInternalAPIAPIService) ListDeviceDeploymentsEntriesExecute(r ApiListDeviceDeploymentsEntriesRequest) ([]DeviceDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DeviceDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.ListDeviceDeploymentsEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant_id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveDeviceFromDeploymentsRequest struct {
	ctx        context.Context
	ApiService *DeploymentsInternalAPIInternalAPIAPIService
	tenantId   string
	id         string
}

func (r ApiRemoveDeviceFromDeploymentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveDeviceFromDeploymentsExecute(r)
}

/*
RemoveDeviceFromDeployments Remove device from all deployments

Set 'decommissioned' status to all pending device deployments for a given device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tenantId Tenant ID
	@param id System wide device identifier
	@return ApiRemoveDeviceFromDeploymentsRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) RemoveDeviceFromDeployments(ctx context.Context, tenantId string, id string) ApiRemoveDeviceFromDeploymentsRequest {
	return ApiRemoveDeviceFromDeploymentsRequest{
		ApiService: a,
		ctx:        ctx,
		tenantId:   tenantId,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) RemoveDeviceFromDeploymentsExecute(r ApiRemoveDeviceFromDeploymentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.RemoveDeviceFromDeployments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{tenant_id}/deployments/devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant_id"+"}", url.PathEscape(parameterValueToString(r.tenantId, "tenantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetStorageLimitRequest struct {
	ctx          context.Context
	ApiService   *DeploymentsInternalAPIInternalAPIAPIService
	id           string
	storageLimit *StorageLimit
}

func (r ApiSetStorageLimitRequest) StorageLimit(storageLimit StorageLimit) ApiSetStorageLimitRequest {
	r.storageLimit = &storageLimit
	return r
}

func (r ApiSetStorageLimitRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetStorageLimitExecute(r)
}

/*
SetStorageLimit Set storage limit for given tenant

Set storage limit for given tenant.
If the limit value is 0 it means storage space is unlimited

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID
	@return ApiSetStorageLimitRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) SetStorageLimit(ctx context.Context, id string) ApiSetStorageLimitRequest {
	return ApiSetStorageLimitRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) SetStorageLimitExecute(r ApiSetStorageLimitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.SetStorageLimit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/limits/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.storageLimit == nil {
		return nil, reportError("storageLimit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.storageLimit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetStorageSettingsRequest struct {
	ctx             context.Context
	ApiService      *DeploymentsInternalAPIInternalAPIAPIService
	id              string
	storageSettings *StorageSettings
}

// Settings to set. If set to null or an empty object, the tenant will use the default settings.
func (r ApiSetStorageSettingsRequest) StorageSettings(storageSettings StorageSettings) ApiSetStorageSettingsRequest {
	r.storageSettings = &storageSettings
	return r
}

func (r ApiSetStorageSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetStorageSettingsExecute(r)
}

/*
SetStorageSettings Set storage settings for a given tenant

Set the storage layer settings for a given tenant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Tenant ID
	@return ApiSetStorageSettingsRequest
*/
func (a *DeploymentsInternalAPIInternalAPIAPIService) SetStorageSettings(ctx context.Context, id string) ApiSetStorageSettingsRequest {
	return ApiSetStorageSettingsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeploymentsInternalAPIInternalAPIAPIService) SetStorageSettingsExecute(r ApiSetStorageSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsInternalAPIInternalAPIAPIService.SetStorageSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/internal/v1/deployments/tenants/{id}/storage/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.storageSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
