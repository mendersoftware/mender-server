/*
Mender API

Combined API specification for the features of the different Mender backend services, suitable for code generation applications

API version: 1
Contact: support@mender.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// DeviceAuthenticationManagementAPIAPIService DeviceAuthenticationManagementAPIAPI service
type DeviceAuthenticationManagementAPIAPIService service

type ApiDeviceAuthManagementCountDevicesRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	status        *string
	xMENRequestID *string
}

// Device status filter, one of &#39;pending&#39;, &#39;accepted&#39;, &#39;rejected&#39;, &#39;noauth&#39;, &#39;preauthorized&#39;. Default is &#39;all devices&#39;, meaning devices with any of these statuses will be counted.
func (r ApiDeviceAuthManagementCountDevicesRequest) Status(status string) ApiDeviceAuthManagementCountDevicesRequest {
	r.status = &status
	return r
}

// A request identification
func (r ApiDeviceAuthManagementCountDevicesRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementCountDevicesRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementCountDevicesRequest) Execute() (*Count, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementCountDevicesExecute(r)
}

/*
DeviceAuthManagementCountDevices Count number of devices, optionally filtered by status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceAuthManagementCountDevicesRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementCountDevices(ctx context.Context) ApiDeviceAuthManagementCountDevicesRequest {
	return ApiDeviceAuthManagementCountDevicesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Count
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementCountDevicesExecute(r ApiDeviceAuthManagementCountDevicesRequest) (*Count, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Count
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementCountDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementDecommissionDeviceRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementDecommissionDeviceRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementDecommissionDeviceRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementDecommissionDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceAuthManagementDecommissionDeviceExecute(r)
}

/*
DeviceAuthManagementDecommissionDevice Remove device and associated authentication set

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Device identifier.
	@return ApiDeviceAuthManagementDecommissionDeviceRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementDecommissionDevice(ctx context.Context, id string) ApiDeviceAuthManagementDecommissionDeviceRequest {
	return ApiDeviceAuthManagementDecommissionDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementDecommissionDeviceExecute(r ApiDeviceAuthManagementDecommissionDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementDecommissionDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementGetAuthenticationStatusRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	aid           string
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementGetAuthenticationStatusRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementGetAuthenticationStatusRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementGetAuthenticationStatusRequest) Execute() (*Status, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementGetAuthenticationStatusExecute(r)
}

/*
DeviceAuthManagementGetAuthenticationStatus Get the device authentication set status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Device identifier.
	@param aid Authentication data set identifier.
	@return ApiDeviceAuthManagementGetAuthenticationStatusRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetAuthenticationStatus(ctx context.Context, id string, aid string) ApiDeviceAuthManagementGetAuthenticationStatusRequest {
	return ApiDeviceAuthManagementGetAuthenticationStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		aid:        aid,
	}
}

// Execute executes the request
//
//	@return Status
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetAuthenticationStatusExecute(r ApiDeviceAuthManagementGetAuthenticationStatusRequest) (*Status, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementGetAuthenticationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/{id}/auth/{aid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aid"+"}", url.PathEscape(parameterValueToString(r.aid, "aid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementGetDeviceRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementGetDeviceRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementGetDeviceRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementGetDeviceRequest) Execute() (*Device, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementGetDeviceExecute(r)
}

/*
DeviceAuthManagementGetDevice Get a particular device.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Device identifier.
	@return ApiDeviceAuthManagementGetDeviceRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetDevice(ctx context.Context, id string) ApiDeviceAuthManagementGetDeviceRequest {
	return ApiDeviceAuthManagementGetDeviceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Device
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetDeviceExecute(r ApiDeviceAuthManagementGetDeviceRequest) (*Device, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementGetDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementGetDeviceLimitRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementGetDeviceLimitRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementGetDeviceLimitRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementGetDeviceLimitRequest) Execute() (*Limit, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementGetDeviceLimitExecute(r)
}

/*
DeviceAuthManagementGetDeviceLimit Obtain limit of accepted devices.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceAuthManagementGetDeviceLimitRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetDeviceLimit(ctx context.Context) ApiDeviceAuthManagementGetDeviceLimitRequest {
	return ApiDeviceAuthManagementGetDeviceLimitRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Limit
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementGetDeviceLimitExecute(r ApiDeviceAuthManagementGetDeviceLimitRequest) (*Limit, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Limit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementGetDeviceLimit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/limits/max_devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementListDevicesRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	status        *string
	id            *[]string
	page          *int32
	perPage       *int32
	xMENRequestID *string
}

// Device status filter. If not specified, all devices are listed.
func (r ApiDeviceAuthManagementListDevicesRequest) Status(status string) ApiDeviceAuthManagementListDevicesRequest {
	r.status = &status
	return r
}

// Device ID filter. Can be repeated to query a set of devices.
func (r ApiDeviceAuthManagementListDevicesRequest) Id(id []string) ApiDeviceAuthManagementListDevicesRequest {
	r.id = &id
	return r
}

// Results page number
func (r ApiDeviceAuthManagementListDevicesRequest) Page(page int32) ApiDeviceAuthManagementListDevicesRequest {
	r.page = &page
	return r
}

// Maximum number of results per page.
func (r ApiDeviceAuthManagementListDevicesRequest) PerPage(perPage int32) ApiDeviceAuthManagementListDevicesRequest {
	r.perPage = &perPage
	return r
}

// A request identification
func (r ApiDeviceAuthManagementListDevicesRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementListDevicesRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementListDevicesRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementListDevicesExecute(r)
}

/*
DeviceAuthManagementListDevices List devices sorted by age and optionally filter on device status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceAuthManagementListDevicesRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementListDevices(ctx context.Context) ApiDeviceAuthManagementListDevicesRequest {
	return ApiDeviceAuthManagementListDevicesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Device
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementListDevicesExecute(r ApiDeviceAuthManagementListDevicesRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementListDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", defaultValue, "form", "")
		r.perPage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementPreauthorizeRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	preAuthSet    *PreAuthSet
	xMENRequestID *string
}

func (r ApiDeviceAuthManagementPreauthorizeRequest) PreAuthSet(preAuthSet PreAuthSet) ApiDeviceAuthManagementPreauthorizeRequest {
	r.preAuthSet = &preAuthSet
	return r
}

// A request identification
func (r ApiDeviceAuthManagementPreauthorizeRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementPreauthorizeRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementPreauthorizeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceAuthManagementPreauthorizeExecute(r)
}

/*
DeviceAuthManagementPreauthorize Submit a preauthorized device.

Authorize a device identity with the server backend. On success the device identity is marked as 'preauthorized', and once the device connects and sends it's first authentication request the device automatically become 'accepted' without explicit user intervention.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceAuthManagementPreauthorizeRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementPreauthorize(ctx context.Context) ApiDeviceAuthManagementPreauthorizeRequest {
	return ApiDeviceAuthManagementPreauthorizeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementPreauthorizeExecute(r ApiDeviceAuthManagementPreauthorizeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementPreauthorize")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preAuthSet == nil {
		return nil, reportError("preAuthSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	// body params
	localVarPostBody = r.preAuthSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementRemoveAuthenticationRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	aid           string
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementRemoveAuthenticationRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementRemoveAuthenticationRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementRemoveAuthenticationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceAuthManagementRemoveAuthenticationExecute(r)
}

/*
DeviceAuthManagementRemoveAuthentication Remove (dismiss) the device authentication set

Removes the device authentication set. Removing 'accepted' authentication set is equivalent to rejecting device and removing authentication set. If there is only one authentication set for the device and the device is 'preauthorized' then the device will also be deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Device identifier.
	@param aid Authentication data set identifier.
	@return ApiDeviceAuthManagementRemoveAuthenticationRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementRemoveAuthentication(ctx context.Context, id string, aid string) ApiDeviceAuthManagementRemoveAuthenticationRequest {
	return ApiDeviceAuthManagementRemoveAuthenticationRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		aid:        aid,
	}
}

// Execute executes the request
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementRemoveAuthenticationExecute(r ApiDeviceAuthManagementRemoveAuthenticationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementRemoveAuthentication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/{id}/auth/{aid}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aid"+"}", url.PathEscape(parameterValueToString(r.aid, "aid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementRevokeAPITokenRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	xMENRequestID *string
}

// A request identification
func (r ApiDeviceAuthManagementRevokeAPITokenRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementRevokeAPITokenRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementRevokeAPITokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceAuthManagementRevokeAPITokenExecute(r)
}

/*
DeviceAuthManagementRevokeAPIToken Revoke JWT with given id

Deletes the token, effectively revoking it. The device must apply for a new one with a new authentication request. The token 'id' corresponds to the standard 'jti' claim.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Unique token identifier('jti').
	@return ApiDeviceAuthManagementRevokeAPITokenRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementRevokeAPIToken(ctx context.Context, id string) ApiDeviceAuthManagementRevokeAPITokenRequest {
	return ApiDeviceAuthManagementRevokeAPITokenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementRevokeAPITokenExecute(r ApiDeviceAuthManagementRevokeAPITokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementRevokeAPIToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/tokens/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementSearchDevicesRequest struct {
	ctx                                      context.Context
	ApiService                               *DeviceAuthenticationManagementAPIAPIService
	deviceAuthManagementSearchDevicesRequest *DeviceAuthManagementSearchDevicesRequest
	page                                     *int32
	perPage                                  *int32
	xMENRequestID                            *string
}

// Device status filter. All properties can be either a single string or an array of strings.
func (r ApiDeviceAuthManagementSearchDevicesRequest) DeviceAuthManagementSearchDevicesRequest(deviceAuthManagementSearchDevicesRequest DeviceAuthManagementSearchDevicesRequest) ApiDeviceAuthManagementSearchDevicesRequest {
	r.deviceAuthManagementSearchDevicesRequest = &deviceAuthManagementSearchDevicesRequest
	return r
}

// Results page number
func (r ApiDeviceAuthManagementSearchDevicesRequest) Page(page int32) ApiDeviceAuthManagementSearchDevicesRequest {
	r.page = &page
	return r
}

// Maximum number of results per page.
func (r ApiDeviceAuthManagementSearchDevicesRequest) PerPage(perPage int32) ApiDeviceAuthManagementSearchDevicesRequest {
	r.perPage = &perPage
	return r
}

// A request identification
func (r ApiDeviceAuthManagementSearchDevicesRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementSearchDevicesRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementSearchDevicesRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.DeviceAuthManagementSearchDevicesExecute(r)
}

/*
DeviceAuthManagementSearchDevices Query for devices. Returns a list of matching devices with AuthSets sorted by age.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeviceAuthManagementSearchDevicesRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementSearchDevices(ctx context.Context) ApiDeviceAuthManagementSearchDevicesRequest {
	return ApiDeviceAuthManagementSearchDevicesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Device
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementSearchDevicesExecute(r ApiDeviceAuthManagementSearchDevicesRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementSearchDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceAuthManagementSearchDevicesRequest == nil {
		return localVarReturnValue, nil, reportError("deviceAuthManagementSearchDevicesRequest is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", defaultValue, "form", "")
		r.perPage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	// body params
	localVarPostBody = r.deviceAuthManagementSearchDevicesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeviceAuthManagementSetAuthenticationStatusRequest struct {
	ctx           context.Context
	ApiService    *DeviceAuthenticationManagementAPIAPIService
	id            string
	aid           string
	status        *Status
	xMENRequestID *string
}

func (r ApiDeviceAuthManagementSetAuthenticationStatusRequest) Status(status Status) ApiDeviceAuthManagementSetAuthenticationStatusRequest {
	r.status = &status
	return r
}

// A request identification
func (r ApiDeviceAuthManagementSetAuthenticationStatusRequest) XMENRequestID(xMENRequestID string) ApiDeviceAuthManagementSetAuthenticationStatusRequest {
	r.xMENRequestID = &xMENRequestID
	return r
}

func (r ApiDeviceAuthManagementSetAuthenticationStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeviceAuthManagementSetAuthenticationStatusExecute(r)
}

/*
DeviceAuthManagementSetAuthenticationStatus Update the device authentication set status

Sets the status of an authentication data set of selected value. Valid state transitions: - 'pending' -> 'accepted' - 'pending' -> 'rejected' - 'rejected' -> 'accepted' - 'accepted' -> 'rejected'

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Device identifier.
	@param aid Authentication data set identifier.
	@return ApiDeviceAuthManagementSetAuthenticationStatusRequest
*/
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementSetAuthenticationStatus(ctx context.Context, id string, aid string) ApiDeviceAuthManagementSetAuthenticationStatusRequest {
	return ApiDeviceAuthManagementSetAuthenticationStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		aid:        aid,
	}
}

// Execute executes the request
func (a *DeviceAuthenticationManagementAPIAPIService) DeviceAuthManagementSetAuthenticationStatusExecute(r ApiDeviceAuthManagementSetAuthenticationStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeviceAuthenticationManagementAPIAPIService.DeviceAuthManagementSetAuthenticationStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/management/v2/devauth/devices/{id}/auth/{aid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"aid"+"}", url.PathEscape(parameterValueToString(r.aid, "aid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.status == nil {
		return nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xMENRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-MEN-RequestID", r.xMENRequestID, "simple", "")
	}
	// body params
	localVarPostBody = r.status
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
